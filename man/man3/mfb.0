


6/21/83                                                    MFB(3)



NAME
     mfb - model frame buffer interface

SYNOPSIS
     #include <~cad/include/mfb.h> in the program source.
     cc [ flags ] files  ~cad/lib/mfb.a -lm [ libraries ]


DESCRIPTION
     These routines provide the user with a virtual graphics
     interface.  They perform the terminal dependent task of
     encoding/decoding graphics code, thereby allowing the user
     to write graphics programs to run on almost any graphics
     device.

     The user opens and initializes a graphics device by calling
     the _M_F_B_O_p_e_n routine that returns a pointer to that device's
     _M_F_B data structure defined at the end of this manual.  By
     maintaining several _M_F_B data structures, an application pro-
     gram can drive several graphics devices simultaneously.
     Once opened, _M_F_B graphics routines can be called to draw
     geometries, draw graphics text, set device parameters, or
     receive keyboard input.  An application program can also use
     any of the several utility routines that perform line clip-
     ping, polygon clipping, or window/viewport transformations.
     Control of the graphics device is released by calling the
     _M_F_B_C_l_o_s_e routine.

     All programs that use _M_F_B routines must include the file
     _m_f_b._h that defines the _M_F_B data structure to contain the
     information provided by _M_F_B_C_A_P(_5).


INITIALIZATION ROUTINES
     MFB *MFBOpen(TerminalName, DeviceName, errorcode)
     char *TerminalName, *DeviceName;
     int *errorcode;
          _M_F_B_O_p_e_n initializes the graphics device and fills the
          _M_F_B data structure with information found in _M_F_B_C_A_P(_5).
          _T_e_r_m_i_n_a_l_N_a_m_e is a pointer to a null terminated string
          containing the name of the graphics device as defined
          in the _m_f_b_c_a_p database file.  This argument has no
          default and can never be null.  _D_e_v_i_c_e_N_a_m_e is a pointer
          to a null terminated string containing the full path
          name to the respective graphics device. If null, _s_t_d_i_n
          and _s_t_d_o_u_t are used by default.  _e_r_r_o_r_c_o_d_e is a diag-
          nostic integer returned by _M_F_B_O_p_e_n. The possible
          returned values for _e_r_r_o_r_c_o_d_e are defined in the _m_f_b._h
          file as follows:






                                                                1






MFB(3)                                                    6/21/83



          #define MFBOK           1    /* successful return */
          #define MFBBADENT      -10   /* Unknown terminal type */
          #define MFBBADMCF      -20   /* Can't open MFBCAP file */
          #define MFBMCELNG      -30   /* MFBCAP entry too long */
          #define MFBBADMCE      -40   /* Bad MFBCAP entry */
          #define MFBINFMCE      -50   /* infinite loop in MFBCAP entry */
          #define MFBBADTTY      -60   /* stdout not in /dev */
          #define MFBBADDEV      -180  /* Can't open or close device */
          #define MFBBADOPT      -190  /* Can't access or set device stat */
          #define MFBBADWRT      -220  /* Error during write */

          Only MFBOK is not a fatal error.


     void SetCurrentMFB(mfb)
     MFB *mfb;
          _S_e_t_C_u_r_r_e_n_t_M_F_B allows the application program to define
          the current graphics device.  All subsequent calls to
          _M_F_B routines will affect the specified device.  Because
          each _M_F_B data structure contains a separate output
          buffer, it is not necessary to flush the output before
          resetting the current output device.  _M_F_B_O_p_e_n returns
          with the opened graphics device defined as the current
          output device.


     int MFBInitialize()
          _M_F_B_I_n_i_t_i_a_l_i_z_e will flush the output buffer and
          (re)initialize the device for graphics input.  The
          graphics device or standard input will be placed in
          CBREAK mode.  See the manual _t_t_y(_4). MFBOK is returned
          if the device was successfully initialized; MFBBADOPT
          is returned if an error was encountered while attempt-
          ing to access or set the device status, and MFBBADTTY
          is returned if standard output can bot be found or
          accessed.


     int MFBClose()
          _M_F_B_C_l_o_s_e will flush the output buffer and release con-
          trol of the graphics device driver.  If the graphics
          device is a _t_t_y, it is returned to the state that
          existed prior to the respective _M_F_B_O_p_e_n call.  MFBOK is
          returned if the device was successfully closed; MFBBA-
          DOPT is returned if an error was encountered while
          attempting to access or set the device status, and
          MFBBADDEV is returned if the output device could not be
          closed.







2






6/21/83                                                    MFB(3)



     int MFBHalt()
          _M_F_B_H_a_l_t will flush the output buffer and release con-
          trol of the graphics device driver.  If the graphics
          device is a _t_t_y, it is returned to the state that
          existed prior to the respective _M_F_B_O_p_e_n call.  _M_F_B_H_a_l_t
          differs from _M_F_B_C_l_o_s_e in that the memory occupied by
          the respective, current _M_F_B data structure is not
          freed.  By calling _M_F_B_I_n_i_t_i_a_l_i_z_e, the graphics device
          will be reinitialized.  This routine is typically used
          by an application program for handling the SIGTSTP sig-
          nal (the keyboard stop signal, usually control-Z ).
          MFBOK is returned if the device was successfully
          returned to its initial state; MFBBADOPT is returned if
          an error was encountered while attempting to access or
          set the device status.


SETTING DEVICE PARAMETERS
     Each of the following routines for setting device parameters
     returns a diagnostice integer that is defined in the _m_f_b._h
     file as follows:

     #define MFBOK           1    /* successful return */
     #define MFBBADLST      -70   /* Illegal line style */
     #define MFBBADFST      -80   /* Illegal fill style */
     #define MFBBADCST      -90   /* Illegal color style */
     #define MFBBADTM1      -100  /* No destructive text mode */
     #define MFBBADTM2      -110  /* No overstriking text mode */
     #define MFBNOBLNK      -150  /* No definable blinkers */
     #define MFBTMBLNK      -160  /* Too many blinkers */
     #define MFBNOMASK      -170  /* No definable read or write mask */
     #define MFBBADALU      -250  /* Cannot set ALU mode */


     int MFBSetLineStyle(styleId)
     int styleId;
          _M_F_B_S_e_t_L_i_n_e_S_t_y_l_e sets the current line style to that
          identified by the integer _s_t_y_l_e_I_d that is greater than
          or equal to zero and less than the value of _m_a_x_L_i_n_e_S_-
          _t_y_l_e_s in the _M_F_B data structure.  The value of _m_a_x_-
          _L_i_n_e_S_t_y_l_e_s can be obtained from the _M_F_B_I_n_f_o routine
          defined below.  Zero is always the _s_t_y_l_e_I_d for solid
          lines.  Except for the solid line style, _M_F_B assumes no
          default set of lines styles.  MFBOK is returned if the
          line style was successfully set to that specified by
          _s_t_y_l_e_I_d or if _s_t_y_l_e_I_d was already the current line
          style; MFBBADLST is returned if _s_t_y_l_e_I_d has an illegal
          value.







                                                                3






MFB(3)                                                    6/21/83



     int MFBSetFillPattern(styleId)
     int styleId;
          _M_F_B_S_e_t_F_i_l_l_P_a_t_t_e_r_n sets the current fill pattern to that
          identified by the integer _s_t_y_l_e_I_d that is greater than
          or equal to zero and less than the value of _m_a_x_F_i_l_l_P_a_t_-
          _t_e_r_n_s in the _M_F_B data structure.  The value of _m_a_x_-
          _F_i_l_l_P_a_t_t_e_r_n_s can be obtained from the _M_F_B_I_n_f_o routine
          defined below.  Solid fill is always defined by _s_t_y_l_e_I_d
          equal to zero.  Other than solid fill, _M_F_B assumes no
          default set of fill patterns.  MFBOK is returned if the
          fill style was successfully set to that specified by
          _s_t_y_l_e_I_d or if _s_t_y_l_e_I_d was already the current fill
          style; MFBBADFST is returned if _s_t_y_l_e_I_d has an illegal
          value.


     int MFBSetChannelMask(channelMask)
     int channelMask;
          _M_F_B_S_e_t_C_h_a_n_n_e_l_M_a_s_k defines the current write mask to be
          the value of _c_h_a_n_n_e_l_M_a_s_k. The channel mask allows
          specific memory planes to be written and erased without
          disturbing other memory planes.  The least significant
          bit of _c_h_a_n_n_e_l_M_a_s_k corresponds to the masked value of
          the first memory plane, etc.  If the corresponding bit
          is zero, the memory plane is write-protected.  The
          number of memory planes can be obtained from the
          _M_F_B_I_n_f_o routine defined below.  MFBOK is returned if
          the write mask was successfully set to _c_h_a_n_n_e_l_M_a_s_k or
          if _c_h_a_n_n_e_l_M_a_s_k was already the current write mask;
          MFBNOMASK is returned if the graphics device does not
          have a definable write mask.


     int MFBSetReadMask(readmask)
     int readmask;
          _M_F_B_S_e_t_R_e_a_d_M_a_s_k defines the current read mask to be the
          value of _r_e_a_d_m_a_s_k. The read mask allows only specific
          memory planes to be read.  MFBOK is returned if the
          read mask was successfully set to _r_e_a_d_M_a_s_k or if _r_e_a_d_-
          _M_a_s_k was already the current read mask;  MFBNOMASK is
          returned if the graphics device does not have a defin-
          able read mask.













4






6/21/83                                                    MFB(3)



     int MFBSetColor(colorId)
     int colorId;
          _M_F_B_S_e_t_C_o_l_o_r sets the current foreground color to that
          identified by the integer _c_o_l_o_r_I_d that is greater than
          or equal to zero and less than the value of _m_a_x_C_o_l_o_r_s
          in the _M_F_B data structure.  The value of _m_a_x_C_o_l_o_r_s can
          be obtained from the _M_F_B_I_n_f_o routine defined below.
          There is no default color map in _M_F_B. MFBOK is returned
          if the foreground color was successfully set to that
          specified by _c_o_l_o_r_I_d or if _c_o_l_o_r_I_d was already the
          current foreground color; MFBBADCST is returned if
          _c_o_l_o_r_I_d has an illegal value.


     int MFBSetTextMode(destructiveBool)
     Bool destructiveBool;
          _M_F_B_S_e_t_T_e_x_t_M_o_d_e defines whether subsequent graphics text
          will overstrike or replace previous text.  If _d_e_s_t_r_u_c_-
          _t_i_v_e_B_o_o_l is true, the text mode is set to destructive
          which means that graphic text will set the background
          color of the font grid to the color that is specified
          by color style zero depending on the currently defined
          ALU operation.  Overstriking mode will only set the
          pixels of the character font to the current foreground
          color.  MFBOK is returned if the graphic text writing
          mode was successfully set to that specified by _d_e_s_t_r_u_c_-
          _t_i_v_e_B_o_o_l or if _d_e_s_t_r_u_c_t_i_v_e_B_o_o_l was already the current
          graphic text writing mode;  MFBBADTM1 is returned if
          the graphics device does not have a destructive graphic
          text mode, and MFBBADTM2 is returned if the graphics
          device does not have an overstriking graphic text mode.


     int MFBSetALUMode(alumode)
     int alumode;
          _M_F_B_S_e_t_A_L_U_M_o_d_e changes the mode by which the graphics
          display is changed when an area of the display is
          over-written.  The four possible modes are JAM (replace
          mode), OR, EOR (exclusive OR), and NOR.  The four valid
          arguments to _M_F_B_S_e_t_A_L_U_M_o_d_e are defined in _m_f_b._h as fol-
          lows:

          #define MFBALUJAM      0     /* set ALU mode to JAM */
          #define MFBALUOR       1     /* set ALU mode to OR */
          #define MFBALUNOR      2     /* set ALU mode to NOR */
          #define MFBALUEOR      3     /* set ALU mode to EOR */

          MFBOK is returned if the ALU mode was successfully set
          to that specified by _a_l_u_m_o_d_e or if _a_l_u_m_o_d_e was already
          the current ALU operation;  MFBBADALU is returned if
          the graphics device does not have the ALU mode speci-
          fied by _a_l_u_m_o_d_e or if _a_l_u_m_o_d_e is an invalid or illegal



                                                                5






MFB(3)                                                    6/21/83



          argument.


     int MFBSetCursorColor(colorId1, colorId2)
     int colorId1, colorId2;
          _M_F_B_S_e_t_C_u_r_s_o_r_C_o_l_o_r sets the graphics cursor to blink
          between the two colors identified by _c_o_l_o_r_I_d_1 and
          _c_o_l_o_r_I_d_2. The constraints on the values for _c_o_l_o_r_I_d_1
          and _c_o_l_o_r_I_d_2 are the same as for _M_F_B_S_e_t_C_o_l_o_r defined
          above.  The frequency of the blinking cursor is fixed
          and can be changed only by modifying the _m_f_b_c_a_p data-
          base file.  MFBOK is returned if the blinking cursor
          colors were successfully set to the specified colors.


     int MFBSetRubberBanding(onFlag, X, Y)
     int X, Y;
     Bool onFlag;
          _M_F_B_S_e_t_R_u_b_b_e_r_B_a_n_d_i_n_g enables/disables rubber banding of
          the pointing device.  If _o_n_F_l_a_g is false, then rubber
          banding is disabled.  When enabled, the center of
          rubber banding is at _X, _Y. Rubber banding is always
          disabled immediately after the pointing device has been
          used.  MFBOK is returned if the rubberbanding mode was
          successfully set to that specified by _o_n_F_l_a_g; MFBNORBND
          is returned if the graphics device does not have rub-
          berbanding in the pointing device.


     int MFBSetBlinker(colorId, red, green, blue, onFlag)
     int colorId;
     int red, green, blue;
     int onFlag;
          _M_F_B_S_e_t_B_l_i_n_k_e_r enables the color identified by _c_o_l_o_r_I_d
          to blink between its currently defined color and the
          color defined by the _r_e_d, _g_r_e_e_n, _b_l_u_e combination.  The
          values of _r_e_d, _g_r_e_e_n, and _b_l_u_e are normalized to 1000.
          If _o_n_F_l_a_g is zero, the blinking is disabled.  The
          number of colors that may be defined as blinkers at any
          given time must be less than the value of _m_a_x_B_l_i_n_k_e_r_s
          in the _M_F_B data structure.  The frequency of the blink-
          ing colors is fixed and can be changed only by modify-
          ing the _m_f_b_c_a_p database file.  MFBOK is returned if the
          color specified by _c_o_l_o_r_I_d was successfully set to the
          desired blinking mode; MFBNOBLNK is returned if the
          graphics device does not have blinking VLT layers, and
          MFBTMBLNK is returned if there are already too many
          active blinking layers.







6






6/21/83                                                    MFB(3)



DEFINING DEVICE PARAMETERS
     Each of the following routines for defining device parame-
     ters returns a negative value if any difficulty is encoun-
     tered.  The possible returned integers are defined in _m_f_b._h
     as follows:

     #define MFBOK           1    /* successful return */
     #define MFBNODFLP      -120  /* No definable line patterns */
     #define MFBNODFFP      -130  /* No definable fill patterns */
     #define MFBNODFCO      -140  /* No definable colors */


     int MFBDefineColor(colorId, red, green, blue)
     int colorId;
     int red, green, blue;
          _M_F_B_D_e_f_i_n_e_C_o_l_o_r redefines the VLT entry for the color
          identified by _c_o_l_o_r_I_d to be the color represented by
          the _r_e_d, _g_r_e_e_n, _b_l_u_e combination where _r_e_d, _g_r_e_e_n, and
          _b_l_u_e are normalized to 1000.  Once the color
          corresponding to _c_o_l_o_r_I_d is redefined, all geometries
          that were written onto the display of a frame buffer
          with _c_o_l_o_r_I_d as the current color will become the new
          color.  MFBOK is returned if the VLT entry for _c_o_l_o_r_I_d
          was successfully defined; MFBNODFCO is returned if the
          graphics device does not have a VLT.


     int MFBDefineFillPattern(styleId, BitArray)
     int styleId;
     int *BitArray;
          _M_F_B_D_e_f_i_n_e_F_i_l_l_P_a_t_t_e_r_n redefines the fill pattern identi-
          fied by _s_t_y_l_e_I_d and returns with _s_t_y_l_e_I_d as the current
          fill style.  _B_i_t_A_r_r_a_y is a pointer to an array of eight
          integers whose least significant eight bits represent
          individual rows in an eight by eight intensity array.
          For example, a fill pattern with an ascending diagonal
          line may be defined by the following eight (decimal)
          integers:


                          1 2 4 8 16 32 64 128 256


          A diagonal-grid fill pattern can be defined with the
          following integer array:


                          257 130 68 40 40 68 130 257







                                                                7






MFB(3)                                                    6/21/83



          MFBOK is returned if the new fill style for _s_t_y_l_e_I_d was
          successfully defined;  MFBNODFFP is returned if the
          graphics device does not have definable fill patterns.


     int MFBDefineLineStyle(styleId, Mask)
     int styleId;
     int Mask;
          _M_F_B_D_e_f_i_n_e_L_i_n_e_S_t_y_l_e defines the line style identified by
          _s_t_y_l_e_I_d to be the pattern contained in the eight least
          significant bits of _M_a_s_k and returns with _s_t_y_l_e_I_d as
          the current line style.  MFBOK is returned if the line
          style for _s_t_y_l_e_I_d was successfully defined;  MFBNODFFP
          is returned if the graphics device does not have defin-
          able line patterns.


INPUT/OUTPUT ROUTINES
     int MFBUpdate()
          _M_F_B_U_p_d_a_t_e flushes the internal output buffer to the
          currently defined output device and will ignore any
          write error that may occur.  A call to this routine is
          ABSOLUTELY necessary to complete any graphics display
          sequence.  _M_F_B_U_p_d_a_t_e returns the number of characters
          sent to the output graphics device or -1 if a write
          error occured.


     int MFBPoint(X, Y, key, button)
     int *X, *Y, *button;
     char *key;
          _M_F_B_P_o_i_n_t enables the graphics pointing device and then
          waits for user input.  If a keyboard key is pressed,
          _M_F_B_P_o_i_n_t returns with _k_e_y containing the character that
          was pressed.  If the pointing device is pressed,
          _M_F_B_P_o_i_n_t returns with the identified viewport coordi-
          nate _X, _Y, the contents of _k_e_y equal to zero, and the
          button mask of the button that was pushed.  The integer
          array _b_u_t_t_o_n_M_a_s_k in the _M_F_B data structure contains all
          possible button mask values that can be returned.
          _M_F_B_P_o_i_n_t returns one of the following values defined in
          the _m_f_b._h file:

          #define MFBOK           1    /* successful return */
          #define MFBPNTERR      -230  /* Error in pointing device */
          #define MFBNOPTFT      -240  /* No pointing format */
          #define MFBNOPNT       -260  /* No pointing device */








8






6/21/83                                                    MFB(3)



     char *MFBKeyboard(X, Y, background, foreground)
     int background;
     int foreground;
     int X, Y;
          _M_F_B_K_e_y_b_o_a_r_d enables the graphics keyboard and waits for
          user input.  A pointer to a character buffer containing
          the keyboard input is returned by _M_F_B_K_e_y_b_o_a_r_d when the
          user presses the return or linefeed key.  Backspace is
          control-H or the delete character, and control-X or
          control-U will kill the line.  Pressing the ESCAPE key
          will cause _M_F_B_K_e_y_b_o_a_r_d to return with a null string in
          the input character buffer.

          All keyboard input is displayed in the viewport with
          the lower left corner at the viewport coordinate _X, _Y
          and is constrained to fit on one line.  _B_a_c_k_g_r_o_u_n_d and
          _f_o_r_e_g_r_o_u_n_d are the background and foreground color
          styles respectively in which the keyboard input will be
          displayed.


     void MFBAudio()
          _M_F_B_A_u_d_i_o will ring the bell or alarm on the graphics
          device.  If the graphics device does not have a bell,
          then a control-G will be sent to standard output.


     int MFBPutchar(c)
     char c;

     int MFBPutstr(cp,nchars)
     int nchars;
     char *cp;

     int MFBGetchar()
          These three routines are used internally by _M_F_B and
          typically are not used within an application program.
          They are comparable to the _s_t_d_i_o routines having simi-
          lar names.  _M_F_B_P_u_t_c_h_a_r places a character _c in the out-
          put buffer.  _M_F_B_P_u_t_s_t_r inserts a string pointed to by
          _c_p containing _n_c_h_a_r_s characters into the output buffer.
          The _n_c_h_a_r_s argument is necessary to permit embedded
          null characters in the output stream.  The characters
          remain in the output buffer until the next call to
          _M_F_B_U_p_d_a_t_e or until the contents of the output buffer
          exceed 4096 characters.

          _M_F_B_G_e_t_c_h_a_r returns a single character from the graphics
          input device.  If the graphics device does not have a
          keyboard, input is obtained from the terminal from
          which the application program was invoked.  If the
          graphics device is a _t_t_y, it should be remembered that



                                                                9






MFB(3)                                                    6/21/83



          it is in CBREAK mode.


TWO DIMENSIONAL GEOMETRY ROUTINES
     All coordinates that are passed to the following geometry
     routines are with respect to the display resolution of the
     graphics device.  _M_F_B assumes that the lower, left corner of
     the display is the origin with an absolute coordinate (0,
     0).  All coordinate values are positive integers.

     void MFBMoveTo(X1, Y1)
     int X1, Y1;
          _M_F_B_M_o_v_e_T_o sets the current graphics position to _X_1, _Y_1.
          No line will be drawn from the old graphics position.


     void MFBDrawLineTo(X1, Y1)
     int X1, Y1;
          _M_F_B_D_r_a_w_L_i_n_e_T_o draws a line from the current graphics
          position to _X_1, _Y_1 in the current line style and color.
          The current graphics position then becomes _X_1, _Y_1.


     void MFBLine(X1, Y1, X2, Y2)
     int X1, Y1, X2, Y2;
          _M_F_B_L_i_n_e draws a line in the current line style and
          color from _X_1, _Y_1 to _X_2, _Y_2.


     void MFBBox(left, bottom, right, top)
     int left, bottom, right, top;
          _M_F_B_B_o_x displays a rectangle in the current fill pattern
          and color with diagonal coordinates at _l_e_f_t, _b_o_t_t_o_m and
          _r_i_g_h_t, _t_o_p.


     void MFBDrawPath(path)
     MFBPATH *path;
          _M_F_B_D_r_a_w_P_a_t_h draws a path of vectors in the current line
          style and color.  _P_a_t_h is a pointer to a data structure
          defined in the _m_f_b._h file as follows:

          struct mfbpath {
                int nvertices; /* number of (x,y) coordinate pairs */
                int *xy;       /* pointer to array of (x,y) coordinates */
                };

          typedef struct mfbpath MFBPATH;

          The contents of the coordinate array are organized such
          that xy[0] is the x coordinate of the first vertex,
          xy[1] is the y coordinate of the first vertex, xy[2] is



10






6/21/83                                                    MFB(3)



          the x coordinate of the second vertex, etc.


     void MFBFlood()
          _M_F_B_F_l_o_o_d erases a frame buffer display to the current
          color as previously defined by _M_F_B_S_e_t_C_o_l_o_r. The result
          would be the same as drawing a solid box over the
          entire display.


     void MFBPixel(X, Y)
     int X, Y;
          _M_F_B_P_i_x_e_l sets the pixel at location _X, _Y on the display
          to the current color as previously defined by
          _M_F_B_S_e_t_C_o_l_o_r.


     void MFBCircle(X, Y, rad, nsides)
     int X, Y, rad, nsides;
          _M_F_B_C_i_r_c_l_e draws the perimeter of a circle in the
          current line style and color with center at _X, _Y and
          with radius _r_a_d. The argument _n_s_i_d_e_s is the number of
          line segments with which the circle will be drawn if
          the frame buffer does not have a circle primitive.  The
          default value for _n_s_i_d_e_s is twenty.


     void MFBFlash(X, Y, rad, nsides)
     int X, Y, rad, nsides;
          _M_F_B_F_l_a_s_h draws a round flash with the current fill pat-
          tern and color with center at _X, _Y and radius _r_a_d. The
          argument _n_s_i_d_e_s is the number of line segments with
          which the flash will be drawn.  The default value for
          _n_s_i_d_e_s is twenty.


     void MFBArc(X, Y, rad, angle1, angle2, nsides)
     int X, Y, rad;
     int angle1, angle2, nsides;
          _M_F_B_A_r_c draws an arc in the current line style and color
          with center at _X, _Y and with radius _r_a_d beginning at
          _a_n_g_l_e_1 with respect to the positive y-axis and ending
          at _a_n_g_l_e_2 in a counter-clockwise direction.  Both
          angles are in degrees and are greater than or equal to
          zero and less than or equal to 360.  The argument
          _n_s_i_d_e_s is the number of line segments with which a 360
          degree arc will be drawn.  The default value for _n_s_i_d_e_s
          is twenty.







                                                               11






MFB(3)                                                    6/21/83



     void MFBPolygon(poly)
     MFBPOLYGON *poly;
          _M_F_B_P_o_l_y_g_o_n draws a polygon with the current fill pat-
          tern and color.  _P_o_l_y is a pointer to a data structure
          defined in the _m_f_b._h file as follows:

          struct mfbpolygon {
                int nvertices; /* number of (x,y) coordinate pairs */
                int *xy;       /* pointer to array of (x,y) coordinates */
                };

          typedef struct mfbpolygon MFBPOLYGON;

          The contents of the coordinate array are organized such
          that xy[0] is the x coordinate of the first vertex,
          xy[1] is the y coordinate of the first vertex, xy[2] is
          the x coordinate of the second vertex, etc.  The
          difference between the _M_F_B_P_O_L_Y_G_O_N typedef and the
          _M_F_B_P_A_T_H typedef defined above is that the _M_F_B_P_O_L_Y_G_O_N
          struct is assumed to define a closed path of coordi-
          nates.


     MFBPATH *MFBArcPath(X, Y, rad, angle1, angle2, nsides)
     int X, Y, rad;
     int angle1, angle2, nsides;
          _M_F_B_A_r_c_P_a_t_h returns a pointer to a _M_F_B_P_A_T_H struct that
          contains an arc with center at _X, _Y and with radius _r_a_d
          beginning at _a_n_g_l_e_1 with respect to the positive y-axis
          and ending at _a_n_g_l_e_2 in a counter-clockwise direction.
          Both angles are in degrees and are greater than or
          equal to zero and less than or equal to 360.  The argu-
          ment _n_s_i_d_e_s is the number of line segments with which
          the arc will be drawn.  The default value for _n_s_i_d_e_s is
          twenty.


     MFBPOLYGON *MFBEllipse(X, Y, radx, rady, nsides)
     int X, Y, rad, nsides;
          _M_F_B_E_l_l_i_p_s_e_P_a_t_h returns a pointer to a _M_F_B_P_O_L_Y_G_O_N struct
          that contains an elliptical polygon with center at _X, _Y
          and with distance _r_a_d_x from the center to an edge along
          the x-axis and distance _r_a_d_y from the center to an edge
          along the y-axis.  The argument _n_s_i_d_e_s is the number of
          line segments with which the arc will be drawn.  The
          default value for _n_s_i_d_e_s is twenty.









12






6/21/83                                                    MFB(3)



     void MFBText(text, X, Y, phi)
     char *text;
     int X, Y, phi;
          _M_F_B_T_e_x_t displays a null terminated string pointed to by
          _t_e_x_t with the lower left corner at _X, _Y in the display
          viewport with the current color and rotated at the
          angle _p_h_i in degrees.  The default value for _p_h_i is
          zero.


     void MFBNaiveBoxFill(left, bottom, right, top)
     int top, bottom, left, right;
          _M_F_B_N_a_i_v_e_B_o_x_F_i_l_l can be used to draw a filled rectangle
          on a graphics device that does not support fill pat-
          terns.  The _M_F_B_L_i_n_e routine is used to draw rectangles
          with eight different fixed fill styles.  If the graph-
          ics device does not have a command primitive for draw-
          ing a box, then the _M_F_B_B_o_x routine defined above
          defaults to _M_F_B_N_a_i_v_e_B_o_x_F_i_l_l.


RASTER ROUTINES
     void MFBRasterCopy(X,Y,DX,DY,DestX,DestY);
     int X,Y,DX,DY,DestX,DestY;
          _M_F_B_R_a_s_t_e_r_C_o_p_y copies a rectangular area with the bot-
          tom, left corner at _X,_Y and with length _D_X in the X
          direcion and width _D_Y in the Y direction to an area
          with the bottom, left corner at _D_e_s_t_X,_D_e_s_t_Y. The mode
          of the copy operation was specified by the last call to
          _M_F_B_S_e_t_A_L_U_M_o_d_e.


INFORMATION ACQUISITION
     int MFBInfo(info);
     int info;
          _M_F_B_I_n_f_o is a routine for obtaining device specific
          information.  The possible values for _i_n_f_o are defined
          in _m_f_b._h as follows:

          #define MAXX               1     /* max x coordinate */
          #define MAXY               2     /* max y coordinate */
          #define MAXCOLORS          3     /* max number of colors */
          #define MAXINTENSITY       4     /* max color intensity */
          #define MAXFILLPATTERNS    5     /* max number of fill patterns */
          #define MAXLINESTYLES      6     /* max number of line styles */
          #define MAXBLINKERS        7     /* max number of blinkers */
          #define POINTINGDEVICE     8     /* terminal has pointing device */
          #define POINTINGBUTTONS    9     /* pointing device has buttons */
          #define NUMBUTTONS         10    /* num. of pointing dev. buttons */
          #define BUTTON1            11    /* value returned by button 1 */
          #define BUTTON2            12    /* value returned by button 2 */
          #define BUTTON3            13    /* value returned by button 3 */



                                                               13






MFB(3)                                                    6/21/83



          #define BUTTON4            14    /* value returned by button 4 */
          #define BUTTON5            15    /* value returned by button 5 */
          #define BUTTON6            16    /* value returned by button 6 */
          #define BUTTON7            17    /* value returned by button 7 */
          #define BUTTON8            18    /* value returned by button 8 */
          #define BUTTON9            19    /* value returned by button 9 */
          #define BUTTON10           20    /* value returned by button 10 */
          #define BUTTON11           21    /* value returned by button 11 */
          #define BUTTON12           22    /* value returned by button 12 */
          #define TEXTPOSITIONALBE   30    /* Bool: positionable text */
          #define TEXTROTATABLE      31    /* Bool: rotatable text */
          #define FONTHEIGHT         32    /* font height in pixels */
          #define FONTWIDTH          33    /* font width in pixels */
          #define FONTXOFFSET        34    /* font x offset in pixels */
          #define FONTYOFFSET        35    /* font y offset in pixels */
          #define DESTRUCTIVETEXT    36    /* Bool: text can be destructive */
          #define OVERSTRIKETEXT     37    /* Bool: text can be overstrike */
          #define VLT                38    /* Bool: terminal has VLT */
          #define BLINKERS           39    /* Bool: terminal has blinkers */
          #define FILLEDPOLYGONS     40    /* Bool: terminal can fill polygons */
          #define DEFFILLPATTERNS    41    /* Bool: definable fill patterns */
          #define DEFCHANNELMASK     42    /* Bool: definable write mask */
          #define DEFLINEPATTERN     43    /* Bool: definable line styles */
          #define CURFGCOLOR         44    /* current foreground color */
          #define CURFILLPATTERN     45    /* current fill pattern */
          #define CURLINESTYLE       46    /* current line style */
          #define CURCHANNELMASK     47    /* current channel mask */
          #define CURREADMASK        48    /* current read mask */
          #define NUMBITPLANES       49    /* number of bit planes */
          #define DEFREADMASK        50    /* Bool: definable read mask */
          #define RASTERCOPY         51    /* Bool: term has raster copy */
          #define OFFSCREENX         52    /* left of off screen memory */
          #define OFFSCREENY         53    /* bottom of off screen memory */
          #define OFFSCREENDX        54    /* length of off screen memory */
          #define OFFSCREENDY        55    /* width of off screen memory */

          If an invalid argument is used, _M_F_B_I_n_f_o will return -1.


WINDOW/VIEWPORT TRANSFORMATIONS
     _M_F_B provides a set of procedures for converting from window
     coordinates to viewport coordinates and vice versa.  These
     transformation routines are NOT used by the _M_F_B display rou-
     tines and must be invoked separately by an application pro-
     gram.

     void MFBSetViewport(left, bottom, right, top)
     int left, bottom, right, top;

     void MFBSetWindow(left, bottom, right, top)
     int left, bottom, right, top;




14






6/21/83                                                    MFB(3)



     int MFBScaleX(X)
     int X;

     int MFBScaleY(Y)
     int Y;

     int MFBDescaleX(X)
     int X;

     int MFBDescaleY(Y)
     int Y;
          To use these routines, it is necessary to define both
          the viewport of the graphics display and the window in
          the working area by using _M_F_B_S_e_t_V_i_e_w_p_o_r_t and _M_F_B_S_e_t_W_i_n_-
          _d_o_w. The viewport must always be defined by non-
          negative integers that are within the resolution of the
          graphics display.  Once defined, _M_F_B_S_c_a_l_e_X and _M_F_B_S_c_a_-
          _l_e_Y will convert from window coordinate values to
          viewport coordinates.  _M_F_B_D_e_s_c_a_l_e_X and _M_F_B_D_e_s_c_a_l_e_Y will
          perform the inverse transformation.  The transform rou-
          tines return the scaled values.


GEOMETRY CLIPPING ROUTINES
     _M_F_B provides a set of routines for clipping lines and
     polygons to a given window.

     void MFB_Y_Intercept(X1, Y1, X2, Y2, value, Yvalue)
     int X1, Y1, X2, Y2;
     int value;
     int *Yvalue;
          _M_F_B__Y__I_n_t_e_r_c_e_p_t calculates the value _Y_v_a_l_u_e of the y
          coordinate at the point of intersection of a line
          defined by the two coordinates _X_1, _Y_1 and _X_2, _Y_2, and a
          vertical line with all x coordinates equal to _v_a_l_u_e.


     void MFB_X_Intercept(X1, Y1, X2, Y2, value, Xvalue)
     int X1, Y1, X2, Y2;
     int value;
     int *Xvalue;
          _M_F_B__X__I_n_t_e_r_c_e_p_t calculates the value _X_v_a_l_u_e of the x
          coordinate at the point of intersection of a line
          defined by _X_1, _Y_1 and _X_2, _Y_2, and a horizontal line
          with all y coordinates equal to _v_a_l_u_e.


     void MFBLineClip(X1, Y1, X2, Y2, left, bottom, right, top);
     int *X1, *Y1, *X2, *Y2;
     int left, bottom, right, top;
          The above clipping routines are used by _M_F_B_L_i_n_e_C_l_i_p to
          clip the line segment defined by _X_1, _Y_1 and _X_2, _Y_2 to



                                                               15






MFB(3)                                                    6/21/83



          the window defined by _l_e_f_t, _b_o_t_t_o_m, _r_i_g_h_t, and _t_o_p.


     void MFBPolygonClip(poly, top, bottom, left, right)
     MFBPOLYGON *poly;
     int top, bottom, left, right;
          _M_F_B_P_o_l_y_g_o_n_C_l_i_p clips a polygon with less than 200 ver-
          tices defined by _p_o_l_y to the window defined by _l_e_f_t,
          _b_o_t_t_o_m, _r_i_g_h_t, and _t_o_p. _p_o_l_y is replaced by the clipped
          polygon.


     MFBPATH *MFBArcClip(path, left, bottom, right, top)
     MFBPATH *path;
     int left, bottom, right, top;
          _M_F_B_A_r_c_C_l_i_p clips an arc with less than 200 vertices
          defined by _p_a_t_h to the window defined by _l_e_f_t, _b_o_t_t_o_m,
          _r_i_g_h_t, and _t_o_p. _M_F_B_C_l_i_p_A_r_c returns a pointer to an
          array of five _M_F_B_P_A_T_H structs that define the clipped
          arc.  The contents of several of these returned structs
          may define a null path.


SPECIAL VIEWPORT ROUTINES
     void MFBMore(left, bottom, right, top, Textfile)
     int left, bottom, right, top;
     FILE *Textfile;
          _M_F_B_M_o_r_e will display the contents of a file _T_e_x_t_f_i_l_e in
          a viewport defined by _l_e_f_t, _b_o_t_t_o_m, _r_i_g_h_t, and _t_o_p in a
          manner similar to the UCB program _M_O_R_E(_1).


     void MFBScroll(left, bottom, right, top, Textfile)
     int left, bottom, right, top;
     FILE *Textfile;
          _M_F_B_S_c_r_o_l_l is an enhanced version of _M_F_B_M_o_r_e defined
          above that allows you to scroll up or down through the
          contents of _T_e_x_t_f_i_l_e. The contents of _T_e_x_t_f_i_l_e are
          displayed in a viewport defined by _l_e_f_t, _b_o_t_t_o_m, _r_i_g_h_t,
          and _t_o_p.


DIAGNOSTICS
     char *MFBError(errnum)
     int errnum;
          _M_F_B_E_r_r_o_r can be used to obtain a null terminated string
          that describes the error associated with any of the
          above mentioned error codes.  _e_r_r_n_u_m is the error code
          returned by a _M_F_B routine.  _M_F_B_E_r_r_o_r returns a pointer
          to the error information string.  The possible values
          for _e_r_r_n_u_m are defined in _m_f_b._h as follows:




16






6/21/83                                                    MFB(3)



          #define MFBBADENT      -10   /* Unknown terminal type */
          #define MFBBADMCF      -20   /* Can't open mfbcap file */
          #define MFBMCELNG      -30   /* MFBCAP entry too long */
          #define MFBBADMCE      -40   /* Bad mfbcap entry */
          #define MFBINFMCE      -50   /* Infinite mfbcap entry */
          #define MFBBADTTY      -60   /* stdout not in /dev */
          #define MFBBADLST      -70   /* Illegal line style */
          #define MFBBADFST      -80   /* Illegal fill style */
          #define MFBBADCST      -90   /* Illegal color style */
          #define MFBBADTM1      -100  /* No destructive text */
          #define MFBBADTM2      -110  /* No overstriking text */
          #define MFBNODFLP      -120  /* No definable line styles */
          #define MFBNODFFP      -130  /* No definable fill styles */
          #define MFBNODFCO      -140  /* No definable colors */
          #define MFBNOBLNK      -150  /* No blinkers */
          #define MFBTMBLNK      -160  /* Too many blinkers */
          #define MFBBADDEV      -180  /* Can't open or close device */
          #define MFBBADOPT      -190  /* Can't access or set device stat */
          #define MFBNOMASK      -170  /* No definable read or write mask */
          #define MFBBADWRT      -200  /* Error in write */
          #define MFBPNTERR      -210  /* Error in pointing device */
          #define MFBNOPTFT      -220  /* No format for pointing device */
          #define MFBNOPNT       -230  /* No pointing device */
          #define MFBNORBND      -240  /* No Rubberbanding */
          #define MFBBADALU      -250  /* Cannot set ALU mode */


     void MFBZeroCounters()

     void MFBCounters(nCh,nBx,BxArea,nLn,LnLngth,nPxl)
     int *nCh,*nBx,*BxArea,*nLn,*LnLngth,*nPxl;
          _M_F_B_C_o_u_n_t_e_r_s provides the ability to measure the commun-
          ications bandwidth between the host and the graphics
          device.  To use these routines, MFB must be compiled
          with the DEBUG flag defined in the _m_f_b._h file.

          The procedure is initialized by invoking _M_F_B_Z_e_r_o_-
          _C_o_u_n_t_e_r_s after which the geometry display routines such
          as _M_F_B_B_o_x or _M_F_B_L_i_n_e may be called in any order.  When
          _M_F_B_C_o_u_n_t_e_r_s is invoked, it will return the number of
          graphic text characters _n_C_h that where displayed, the
          number of boxes _n_B_x displayed, the number of lines _n_L_n
          displayed, the average pixel area of a box _B_x_A_r_e_a, the
          average line length _L_n_L_n_g_t_h in pixels, and the total
          number of pixels _n_P_x_l that where affected.  Invocation
          of _M_F_B_C_o_u_n_t_e_r_s does not clear the the counters.









                                                               17






MFB(3)                                                    6/21/83



THE MFB DATA STRUCTURE
     The _M_F_B data structure is listed below.

     #define TTY     't'
     #define HCOPY   'r'

     typedef enum {false, true} Bool;

     struct mfb_window {
         int left;
         int right;
         int top;
         int bottom;
         double length,width;
         };

     typedef struct mfb_window WINDOW;
     typedef struct mfb_window VIEWPORT;

     struct mfbpath {
         int nvertices;
         int *xy;
         };

     typedef struct mfbpath MFBPOLYGON;
     typedef struct mfbpath MFBPATH;

     #ifndef vms
     struct mfbremttyb {
         struct sgttyb oldttyb;
         struct sgttyb newttyb;
         };

     struct mfbremstat {
         int graphttyw;              /* old mode bits of graphics device */
         int kybrdttyw;              /* old mode bits of standard I/O */
         struct stat graphstat;      /* old fstats of graphics device */
         struct stat kybrdstat;      /* old fstats of standard I/O */
         };

     typedef struct mfbremttyb MFBSAVETTYB;
     typedef struct mfbremstat MFBSAVESTAT;
     #endif

     struct mfbformatstrs {
         char *startSequence;        /* first transmitted sequence */
         char *endSequence;          /* last transmitted sequence */
         char *initLineStyles;       /* initialize line styles */
         char *initFillPatterns;     /* initialize fill styles */
         char *initColorStyles;      /* initialize color styles */





18






6/21/83                                                    MFB(3)



         char *vltEntry;             /* define color in VLT */
         char *setForegroundColor;   /* set current foreground color */
         char *screenFlood;          /* flood screen to current color */

         char *channelMaskSet;       /* set write mask */
         char *readMaskSet;          /* set read mask */

         char *enablePointingDevice; /* initialize pointing device */
         char *enableRubberBanding;  /* turn on rubber banding */
         char *disablePointingDevice;        /* disable pointing device and cursor */
         char *disableRubberBanding; /* turn off rubber banding */
         char *readPointingDevice;   /* wait and read pointing device */
         char *formatPointingDevice; /* decode format for pointing device */

         char *keyboardStart;        /* initailize keyboard */
         char *keyboardEnd;          /* terminate keyboard input */
         char *keyboardBackspace;    /* keyboard backspace sequence */
         char *audio;                /* ring the terminals bell */

         char *lineDefineStart;      /* begin defining a line pattern */
         char *lineDefineFormat;     /* define bit array of line pattern */
         char *lineDefineEnd;        /* terminate line pattern definition */
         char *setLineStyle;         /* set current line style */
         char *setSolidLineStyle;    /* set current line style to solid */
         char *movePenSequence;      /* move current graphics position */
         char *drawLineSequence;     /* draw a line in current style */
         char *drawSolidLineSequence;        /* draw a solid line */
         char *drawLineToSequence;   /* move and draw current position */
         char *drawSolidLineToSequence;      /* move and draw solid line */

         char *drawBoxSequence;      /* draw box in current style */
         char *drawSolidBoxSequence; /* draw a solid box */

         char *beginPlygnSequence;   /* begin polygon in cur. fill style */
         char *beginSolidPlygnSequence;      /* begin solid polygon */
         char *sendPlygnVertex;      /* define one point in polygon */
         char *endPlygnSequence;     /* terminate polygon sequence */

         char *drawCircleSequence;   /* draw a circle in solid line style */

         char *rotateTextSequence;   /* rotate graphic text */
         char *graphicsTextStart;    /* begin graphic text */
         char *graphicsTextEnd;      /* terminate graphic text */
         char *replaceON;            /* turn on destructive text mode */
         char *overstrikeON;         /* turn on overstriking text mode */
         char *writePixel;           /* write one pixel in current color */

         char *setALUEOR;            /* set ALU mode to EOR */
         char *setALUNOR;            /* set ALU mode to NOR */
         char *setALUOR;             /* set ALU mode to OR */
         char *setALUJAM;            /* set ALU mode to JAM or REPLACE */




                                                               19






MFB(3)                                                    6/21/83



         char *blinkerON;            /* make a color blink */
         char *blinkerOFF;           /* turn off a blinking layer */

         char *rastCopyStart;        /* begin raster copy sequence */
         char *rastCopyEnd;          /* terminate raster copy sequence */
         char *rastCopyDest;         /* define raster copy destionation */
         char *rastCopySource;       /* define raster copy source area */

         char *fillDefineStart;      /* begin defining a fill style */
         char *fillDefineFormat;     /* define bit array of row/column */
         char *fillDefineEnd;        /* terminate fill style definition */
         char *setFillPattern;       /* set current fill pattern */
         char *setSolidFillPattern;  /* set current fill pattern to solid */
         };


     struct mfb {        /* MFB DATA STRUCT */

                         /*
                          * INTEGERS FIELDS
                          */
     /* used for decode */                    int lastX,lastY;/* for Tektronix encoding */
                         int X,Y,Z,T;         /* parameter list */

     /* Resolution */    int maxX;            /* horizontal resolution */
                         int maxY;            /* vertical resolution */
                         int maxColors;       /* maximum number of colors */
                         int minOffScreenX;   /* left of off screen memory */
                         int minOffScreenY;   /* bottom of off screen mem. */
                         int offScreenDX;     /* length of off screen mem. */
                         int offScreenDY;     /* width of off screen mem. */

     /* Video Layer Table */                  int maxIntensity;/* max RGB or LS intensity */
                         int lengthOfVLT;     /* number of bit planes */

     /* Pointing Device */                    int buttonMask[12];/* returned button masks */
                         int numberOfButtons; /* 12 maximum */

     /* Keyboard Control */                   int keyboardYOffset;
                         int keyboardXOffset;

     /* Line Drawing */  int lineDefineLength;        /* number of bytes in array */
                         int maxLineStyles;   /* number of line styles */

     /* Text font */     int fontHeight;      /* font height in pixels */
                         int fontWidth;       /* font width in pixels */
                         int fontXOffset;
                         int fontYOffset;

     /* Blinkers */      int maxBlinkers;     /* number of blinkers */





20






6/21/83                                                    MFB(3)



     /* Fill Patterns */ int fillDefineHeight;        /* number of byte rows */
                         int fillDefineWidth; /* number of byte columns */
                         int maxFillPatterns; /* number of fill patterns */

     /* Current variables */                  int cursorColor1Id;/* blinked cursor color ID */
                         int cursorColor2Id;  /* unblinked cursor color ID */
                         int fgColorId;       /* cur. foreground color ID */
                         int fillPattern;     /* cur. fill pattern ID */
                         int lineStyle;       /* cur. line style ID */
                         int channelMask;     /* cur. write mask */
                         int readMask;        /* cur. read mask */
                         int numBlinkers;     /* cur. number of blinkers */
                         int textMode;        /* text mode (1=dest, 0=rep) */
                         int stipplePattern[8];       /* cur. stipple pattern */

                         int fileDesc;        /* desc. for graphics device */
                         int numTtyBuffer;    /* cur. chars in output queue */


                         /*
                          * POINTERS
                          */
     /* for tty's only */                     char *name;/* device name */
                         char *terminalName;  /* name of MFBCAP entry */

     /* I/O routines */  int (*dsply_getchar)();
                         int (*kybrd_getchar)();
                         int (*dsply_ungetchar)();
                         int (*kybrd_ungetchar)();
                         int (*outchar)();
                         int (*outstr)();


                         /*
                          * BOOLEANS
                          */
                         Bool initializedBool;

     /* Video Layer Table */                  Bool vltBool;
                         Bool vltUseHLSBool;

     /* Channel Mask */  Bool channelMaskBool;
                         Bool readMaskBool;

     /* Pointing Device */                    Bool PointingDeviceBool;
                         Bool buttonsBool;
                         Bool readImmediateBool;

     /* Keyboard Control */                   Bool keyboardBool;

     /* Line Drawing */  Bool linePatternDefineBool;
                         Bool reissueLineStyleBool;



                                                               21






MFB(3)                                                    6/21/83



     /* Polygon Drawing */                    Bool filledPlygnBool;

     /* Text font */     Bool textPositionableBool;
                         Bool textRotateBool;
                         Bool replaceTextBool;
                         Bool overstrikeTextBool;

     /* Blinkers */      Bool blinkersBool;

     /* Raster Copy */   Bool rastCopyBool;
                         Bool rastRSCSFBool;

     /* Fill Patterns */ Bool fillPtrnDefineBool;
                         Bool fillDefineRowMajorBool;

     /* for tty's only */                     Bool litout;
                         Bool raw;
                         Bool ttyIsSet;


         /*
          * STRUCTURES
          */
         struct mfbformatstrs strings;   /* format strings */

         WINDOW currentWindow;           /* current window */
         VIEWPORT currentViewport;       /* current viewport */

     #ifndef vms
         /* graphics device ttyb struct */
         MFBSAVETTYB graphTtyb;

         /* keyboard ttyb struct if graphics device does not have a kybrd */
         MFBSAVETTYB kybrdTtyb;

         /* tty status ints */
         MFBSAVESTAT oldstat;
     #endif


         /*
          * CHARACTERS
          */
         char deviceType;                /* TTY=tty, HCOPY=hard copy */
         char strBuf[BUFSIZE];           /* storage for format strings */
         char ttyBuffer[TTYBUFSIZE];     /* tty output buffer */
         };

     typedef struct mfb MFB;






22






6/21/83                                                    MFB(3)



EXAMPLE
     The following C program is a simple example that uses
     several _M_F_B routines.  The terminal type is assumed to be
     the first command line argument.  This program will display
     several triangles in different line styles, display at four
     angles of rotation the text that is returned from _M_F_B_K_e_y_-
     _b_o_a_r_d, draw a solid line between two points, and draw an arc
     clipped to a rectangle.




          #include <cad/mfb.h>

          main(argc, argv)
              int argc;
              char *argv[];
              {
              int i, j, k, m;
              int X1, X2, Y1, Y2;
              int numcolors;
              int numlinestyles;
              int button;
              int error;
              MFB *mfb, *MFBOpen();
              MFBPATH *pp;
              char key;
              char *TypeIn;

              /* open graphics device */
              mfb = MFBOpen(argv[1], NULL, &error);

              /* exit on any error */
              if(error < 0) {
                  fprintf(stderr, "error:  %s\n", MFBError(error));
                  exit(0);
                  }

              /* get device information */
              X1 = MFBInfo(MAXX)/2;
              X2 = X1/2;
              Y1 = MFBInfo(MAXY)/30;
              numcolors = MFBInfo(MAXCOLORS);
              numlinestyles = MFBInfo(MAXLINESTYLES);
              if(numcolors > 7)
                  numcolors = 7;
              if(numlinestyles > 7)
                  numlinestyles = 7;







                                                               23






MFB(3)                                                    6/21/83



              /* draw pyramid of lines in different line styles */
              for(j=0; j<28; ++j) {
                  /* set color (increment by one to prevent 'invisible' lines) */
                  k = j % (numcolors - 1);
                  MFBSetColor(k + 1);

                  /* define and set line style */
                  m = j % numlinestyles;
                  MFBDefineLineStyle(m, j * 6);
                  MFBSetLineStyle(m);

                  /* draw pyramid */
                  MFBLine(0, 0, X2, Y1*j + 2*j);
                  MFBLine(X1, 0, X2, Y1*j + 2*j);
                  }

              /* flush output */
              MFBUpdate();

              /* test of MFBKeyboard */
              MFBText("Test of MFBKeyboard.", X2, Y1*28, 0);
              TypeIn = MFBKeyboard(X1, 5, 0, 1);
              MFBText(TypeIn, X1, 70, 0);
              MFBText(TypeIn, X1, 70, 90);
              MFBText(TypeIn, X1, 70, 180);
              MFBText(TypeIn, X1, 70, 270);
              MFBUpdate();
              sleep(3);

              /* test of MFBPoint */
              MFBSetColor(1);
              MFBFlood();
              MFBSetColor(0);
              MFBText("Test of MFBPoint.", X2, Y1*28, 0);
              MFBPoint(&X1, &Y1, &key, &button);
              MFBPoint(&X2, &Y2, &key, &button);
              MFBSetLineStyle(0);
              MFBLine(X1, Y1, X2, Y2);

              /* draw outline of box to contain arc */
              MFBLine(100, 100, 100, 350);
              MFBLine(100, 100, 370, 100);
              MFBLine(370, 100, 370, 350);
              MFBLine(100, 350, 370, 350);

              /* test of MFBArcPath and MFBClipArc */
              i = 0;
              pp = MFBClipArc(MFBArcPath(70, 70, 200, 0, 0, 30), 100, 100, 370, 350);
              while(pp[i].nvertices != 0 && i < 4) {
                  MFBDrawPath(&pp[i]);
                  i++;
                  }



24






6/21/83                                                    MFB(3)



              /* flush output and wait */
              MFBUpdate();
              sleep(6);

              MFBClose();
              }




DEBOUNCING THE POINTING DEVICE
     The following C program is another example of using _M_F_B rou-
     tines that demonstrates several methods of debouncing the
     pointing device.  Several graphics terminals can return
     bogus pointing reports that can be serious and annoying in
     some applications.  Identifying these bogus reports is very
     terminal dependent (e.g. the AED 512 returns bad button
     masks, the Metheus 400 returns negative coordinates, etc.),
     and it is therefore necessary to use all possible tests.



          #include <cad/mfb.h>
          #ifdef vms
          #include <timeb.h>
          #else
          #include <sys/timeb.h>
          #endif

          /*
           * This is the minimum time in milliseconds
           * between accepted pointing events.
           */
          #define DEBOUNCETIME 100

          /*
           * we keep track of the time between pointing
           * events to debounce the cursor
           */
          static long LastPointTime = 0;

          /*
           * routine to read and debounce pointing device.
           */
          point(pointX,pointY,Key,Mask)
              int *pointX,*pointY,*Mask;
              char *Key;
              {
              struct timeb now;
              long newtime;
              int X,Y,Buttons;
              char KeyTyped;



                                                               25






MFB(3)                                                    6/21/83



              SetDebounceTime();
              /* Loop until DEBOUNCETIME has passed */
              while(True) {

                  /* Loop until valid report is received */
                  while(True) {

                      /* Get pointing event */
                      MFBPoint(&X,&Y,&KeyTyped,&Buttons);

                      /* Was a character typed? */
                      if(Key != 0)
                          break;

                      /* Does the pointing device have buttons? */
                      if(MFBInfo(POINTINGBUTTONS)){
                          /*
                           * Test button masks and vicinity of coordinate.
                           * Assume a four button mouse.
                           */
                          if((Buttons == MFBInfo(BUTTON1) ||
                              Buttons == MFBInfo(BUTTON2) ||
                              Buttons == MFBInfo(BUTTON3) ||
                              Buttons == MFBInfo(BUTTON4)) &&
                              (X < MFBInfo(MAXX) && X > 0 &&
                              Y < MFBInfo(MAXY) && Y > 0))
                              break;
                          }
                      }
                  ftime(&now);
                  newtime = 1000 * now.time + now.millitm;
                  if((newtime - LastPointTime) < DEBOUNCETIME) continue;
                  SetDebounceTime();
                  }
              *pointX = X;
              *pointY = Y;
              *Key = KeyTyped;
              *Mask = Buttons;
              }


          SetDebounceTime(){
              struct timeb now;
              ftime(&now);
              LastPointTime = 1000 * now.time + now.millitm;
              }









26






6/21/83                                                    MFB(3)



NOTES
     On some systems, _M_F_B is contained in /usr rather than ~cad.

     _M_F_B will also compile to run under _V_M_S (a trademark of Digi-
     tal Equipment Corp.) or any other operating system.  How-
     ever, special I/O routines such as those in
     ~cad/src/mfb/vmsio.c must be provided for _M_F_B to function
     properly.

     _M_F_B was written to be utmost UNIX compatible and consistent
     with the style of the C programming language.  For example,
     a control sequence always begins with a call to an (_M_F_B)_O_p_e_n
     routine and is terminated by a call to a (_M_F_B)_C_l_o_s_e routine.
     Another example is the provision of the _M_F_B_H_a_l_t routine that
     is intended primarily for the handling of the SIGTSTP sig-
     nal.  One possible exception to the style of C is the use of
     a global output descriptor that is set by a call to the
     _S_e_t_C_u_r_r_e_n_t_M_F_B routine, as opposed to passing the output
     descriptor as an argument to ever active function call.

     _M_F_B was initially aimed toward the modeling of lower perfor-
     mance graphics terminals (e.g., there is currently no sup-
     port of segments or definable windows and viewports at the
     device level).  As a result, programs that use _M_F_B are
     likely to work on the low performance (least expensive)
     graphics terminals as well as on the more expensive devices.


BUGS
     Raster (hard copy) output is not yet implemented.


FUTURE ENHANCEMENTS
     Future modifications to _M_F_B may include the following:

          Extension to hard copy graphics devices.

          Definable vector and raster character fonts.

          Improved cursor support including a definable cursor
          font, cursor tracking by the host, cursor-on/cursor-off
          capability, and cursor report without event.

          Window/viewport geometry clipping by the terminal if
          the device possesses that capability.

          Bit block transfer (BitBlt).


FILES
     ~cad/lib/mfbcap
     ~cad/include/mfb.h



                                                               27






MFB(3)                                                    6/21/83



     ~cad/lib/mfb.a
     ~cad/src/mfb


SEE ALSO
     mfbcap(5), termcap(5), curses(3), more(1), kic(CAD1)


AUTHOR
     Giles Billingsley
     Ken Keller












































28






6/21/83                                                    MFB(3)



STATUS
     The following is a list of the terminals that will currently
     work with _M_F_B:

     4014    Tektronix 4014 with thumbwheels
     4113    Tektronix 4112/4113 with thumbwheels or tablet
     AED5    AED 512 with joystick or tablet
     AED7    AED 767 with joystick or tablet
     2648    HP 2648 black and white grahpics terminal with tablet
     9872    HP 9872 color pen plotter
     D125    DEC VT125 black and white graphics terminal

     The following table lists routines that depend on device
     capabilities and may not work on all graphics devices.
     Other _M_F_B routines that are not listed below will work for
     all devices.

8          ____________________________________________________________________________________________________
                                  4   4   A   A   2   9   D
                                  0   1   E   E   6   8   1
               Routine            1   1   D   D   4   7   2
                                  4   3   5   7   8   2   5
8          ____________________________________________________________________________________________________
           MFBSetLineStyle        X   X   X   X   X   X   X
           MFBSetFillPattern          X   X   X   X   X   X
           MFBSetChannelMask              X   X
           MFBSetReadMask                 X   X
           MFBSetColor                X   X   X   X   X   X
           MFBSetTextMode             X
           MFBSetALUMode              X           X
           MFBSetCursorColor              X   X
           MFBSetRubberBanding        X           X
           MFBSetBlinker                  X   X
8          __________________________________________________
           MFBDefineColor             X   X   X
           MFBDefineFillPattern       X   X   X   X
           MFBDefineLineStyle             X   X   X
8          __________________________________________________
           MFBMoveTo              X   X   X   X   X   X   X
           MFBDrawLineTo          X   X   X   X   X   X   X
           MFBLine                X   X   X   X   X   X   X
           MFBDrawPath            X   X   X   X   X   X   X
           MFBBox                 X   X   X   X   X   X   X
           MFBPolygon             X   X   X   X   X   X   X
           MFBFlood                   X   X   X   X       X
           MFBPixel               X   X   X   X   X   X   X
           MFBCircle              X   X   X   X   X   X   X
           MFBFlash               X   X   X   X   X   X   X
           MFBArc                 X   X   X   X   X   X   X
           MFBText                X   X   X   X   X   X   X
8          __________________________________________________
           MFBPoint               X   X   X   X   X
           MFBKeyboard            X   X   X   X   X       X
           MFBMore                    X   X   X   X       X
           MFBScroll                  X   X   X   X       X



                                                               29


9


MFB(3)                                                    6/21/83



8          ____________________________________________________________________________________________________
799         |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|7777777777777777|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|
77777777777777777799                                                           |99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|7777777777777777|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|99|


































9


30



